# PACKAGES
library(rgdal) #note: we're reading the data differently this time, reading the data using rgdal
# instead of using sf, create a Spatial Polygons Data Frame (SPDF)
#So take a look at the package:
library(help="rgdal")  # perhaps a closer look
# I think this script uses all of these:
library(tmap)
library(spatstat)  # Used for the dirichlet tessellation function for nn
library(maptools)  # Used for conversion to SPDF for nearest neighbor
library(raster)    # Used to clip out thiessen polygons for nearest and idw
library(gstat) # Use gstat's idw routine
library(sp)    # Used for the spsample function for idw
library(interp) # just what it sounds like! Nice package...
library(rgl) # notably the persp3d() function for a spike plot
library(automap) # for autoKrige function at end; "automatic interpolator"
library(ggplot2)
so2 <- as.data.frame(so2) # why this step? See line 38
head(so2)
### PART ONE: DATA MGMT
#Create greenhouse gas source Points Data Frame from .csv
so2 <- read.csv("EPA_S02_MaxReading_MidAtl_062019.csv", header = TRUE)
#Convert to a points spatial data frame (an sp object)
so2.spdf <- SpatialPointsDataFrame(so2[,c("x","y")], data = so2, proj4string = CRS("+init=epsg:4326"))
#this new object is an SPDF. note the various slots, including the coords
plot(so2.spdf)
proj4string(so2.spdf)
ghg_utm <- spTransform(so2.spdf, CRS("+init=epsg:26918")) ## NOTE: change to ghg_utm ("GreenHouseGas")
proj4string(ghg_utm) #Projected into UTM (this could be any other planar projection)
plot(ghg_utm)
# Read in midatl
midatl <- readOGR(dsn="C:\\Users\\tuo27112\\OneDrive - Temple University\\Advanced Statistics\\Datasets", layer="MidAtlStates_WGS")
plot(midatl)
midatl <- spTransform(midatl, CRS("+init=epsg:26918"))
plot(midatl)
plot(ghg_utm, add=T) # note the "add=T" argument and what it does
# Replace point boundary extent with that of midatl?
# What is purpose of this step?
midatl@bbox
ghg_utm@bbox
ghg_utm@bbox <- midatl@bbox
ghg_utm@bbox
tm_shape(midatl) + tm_polygons() +
tm_shape(ghg_utm) +
tm_dots(col="SO2_MaxReading", palette = "Greens", title="Sampled Sulfur Dioxide Emissions \n(ppm)", size=0.7) +
tm_legend(legend.outside=TRUE)
### METHOD ONE: NEAREST NEIGHBOR ESTIMATE USING THIESSEN (aka dirichelet or voronoi) POLYGONS
# Create a tessellated surface
library(dismo)
voron <- voronoi(ghg_utm)
plot(voron)
midatl_agg <- aggregate(midatl)
voron_midatl <- intersect(midatl, voron)
plot(voron_midatl)
spplot(voron_midatl, 'so2',col.regions=rev(get_col_regions()))
spplot(voron_midatl, 'SO2_MaxReading',col.regions=rev(get_col_regions()))
# First step: Create an empty grid where n is the total number of cells
#think of this as an emptry container to store the results of the interpolation
grd              <- as.data.frame(spsample(ghg_utm, "regular", n=50000))
# note: the key input here is ghg_utm, the EPA air quality monitoring sites
# this establishes the bounding box of a grid with give or take 50,000 cells
# examine the object "grd" in the environments. How many cells are there actually?
# note also grd is just a data frame. Watch what happens during these next steps:
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y") #take another look at "grd" again. It is now a set of "Large SpatialPoints"
gridded(grd)     <- TRUE  # Create SpatialPixel object # Now "grd" is a set of "Large SpatialPixels"
fullgrid(grd)    <- TRUE  # Create SpatialGrid object # Now "grd" is a SpatialGrid. That means it contains topological properties of cells
# Add grd's projection information to the empty grid
proj4string(ghg_utm) <- proj4string(ghg_utm) # no idea why this is necessary, but line 143 doesn't run without it!
proj4string(grd) <- proj4string(ghg_utm)
proj4string(grd)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
ghg.idw <- gstat::idw(so2 ~ 1, ghg_utm, newdata=grd, idp=2.0)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
ghg.idw <- gstat::idw(SO2_MaxReading ~ 1, ghg_utm, newdata=grd, idp=2.0)
idw.raster <- raster(ghg.idw) # turns the "ghg.idw" object into a raster
midatlidw <- mask(idw.raster,midatl)
# Plot the estimate
tm_shape(midatlidw) +
tm_raster(n=10,palette = "RdBu", auto.palette.mapping = FALSE,
title="Predicted Sulfur Dioxide \n(in ppm)") +
tm_shape(ghg_utm) + tm_dots(size=0.2) +
tm_legend(legend.outside=TRUE)
tm_shape(midatl) + tm_polygons() +
tm_shape(ghg_utm) +
tm_dots(col="SO2_MaxReading", palette = "Greens", title="Sampled Sulfur Dioxide Emissions \n(ppm)", size=0.7) +
tm_legend(legend.outside=TRUE)
tm_shape(midatl) + tm_polygons() +
tm_shape(ghg_utm) +
tm_dots(col="SO2_MaxReading", palette = "Greens", title="Maximum Sulfur Dioxide Reading \n(ppb)", size=0.7) +
tm_legend(legend.outside=TRUE)
# Plot the estimate
tm_shape(midatlidw) +
tm_raster(n=10,palette = "RdBu", auto.palette.mapping = FALSE,
title="Predicted Max Sulfur Dioxide \n(in ppb)") +
tm_shape(ghg_utm) + tm_dots(size=0.2) +
tm_legend(legend.outside=TRUE)
## test it out - this is a good way of checking that your sample points are all well within your grid.
# If they are not, try some different values in you r x and y ranges:
plot(grd, cex=1.5)
points(ghg_utm, pch=1, col='red', cex=1)
title("Interpolation Grid and Sample Points")
# First create the variogram (differences in so2 by distances between points)
variogcloud <- variogram(so2~1, locations=ghg_utm, data=ghg_utm, cloud=TRUE)
plot(variogcloud)
# First create the variogram (differences in so2 by distances between points)
variogcloud <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm, cloud=TRUE)
plot(variogcloud)
# Now plot the lagged differences (differences by distance)
semivariog <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm)
plot(semivariog)
semivariog
#what is the shape of the semivariogram? Some possibilities:
vgm()
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=200, model="Sph", nugget=100, range=50000)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=200, model="Sph", nugget=100, range=50000)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
# perform the kriging operation, creation "krig" object (inspect it!)
krig <- krige(formula <- so2 ~ 1, locations=ghg_utm, newdata=grd, model=model.variog)
# perform the kriging operation, creation "krig" object (inspect it!)
krig <- krige(formula <- SO2_MaxReading ~ 1, locations=ghg_utm, newdata=grd, model=model.variog)
# send results to a data frame for mapping
krig.output <- as.data.frame(krig)
names(krig.output)[1:3] <- c("long","lat","var1.pred")
krig.raster <- raster(krig)
midatl.krig <- mask(krig.raster, midatl)
# Plot the estimate
tm_shape(midatl.krig) +
tm_raster(n=10,palette = "RdBu", auto.palette.mapping = FALSE,
title="Predicted Sulfur Dioxide \n(in ppm)") +
tm_shape(ghg_utm) + tm_dots(size=0.2) +
tm_legend(legend.outside=TRUE)
plot(variogcloud)
# Now plot the lagged differences (differences by distance)
semivariog <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm)
plot(semivariog)
semivariog
#what is the shape of the semivariogram? Some possibilities:
vgm()
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=200, model="Sph", nugget=100, range=50000)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
fit.variogram(semivariog, vgm(c("Lin", "Sph", "Mat", "Exp")))
fit.variogram(semivariog, vgm(c("Lin", "Sph", "Mat", "Exp")))
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=200, model="Lin", nugget=100, range=50000)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=200, model="Sph", nugget=100, range=50000)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
fit.variogram(semivariog, vgm(c("Lin", "Sph", "Mat", "Exp")))
# PRELIMINARIES
rm(list = ls()) #clears environment
cat("\014") #clears console
# PACKAGES
library(rgdal) #note: we're reading the data differently this time, reading the data using rgdal
library(tmap)
library(spatstat)  # Used for the dirichlet tessellation function for nn
library(maptools)  # Used for conversion to SPDF for nearest neighbor
library(raster)    # Used to clip out thiessen polygons for nearest and idw
library(gstat) # Use gstat's idw routine
library(sp)    # Used for the spsample function for idw
library(interp) # just what it sounds like! Nice package...
library(rgl) # notably the persp3d() function for a spike plot
library(automap) # for autoKrige function at end; "automatic interpolator"
library(ggplot2)
### PART ONE: DATA MGMT
#Create greenhouse gas source Points Data Frame from .csv
so2 <- read.csv("EPA_S02_MaxReading_MidAtl_062019.csv", header = TRUE)
so2 <- as.data.frame(so2) # why this step? See line 38
head(so2)
#Convert to a points spatial data frame (an sp object)
so2.spdf <- SpatialPointsDataFrame(so2[,c("x","y")], data = so2, proj4string = CRS("+init=epsg:4326"))
#this new object is an SPDF. note the various slots, including the coords
plot(so2.spdf)
proj4string(so2.spdf)
ghg_utm <- spTransform(so2.spdf, CRS("+init=epsg:26918")) ## NOTE: change to ghg_utm ("GreenHouseGas")
proj4string(ghg_utm) #Projected into UTM (this could be any other planar projection)
plot(ghg_utm)
# Read in midatl
midatl <- readOGR(dsn="C:\\Users\\tuo27112\\OneDrive - Temple University\\Advanced Statistics\\Datasets", layer="MidAtlStates_WGS")
plot(midatl)
midatl <- spTransform(midatl, CRS("+init=epsg:26918"))
plot(midatl)
plot(ghg_utm, add=T) # note the "add=T" argument and what it does
# Replace point boundary extent with that of midatl?
# What is purpose of this step?
midatl@bbox
ghg_utm@bbox
ghg_utm@bbox <- midatl@bbox
ghg_utm@bbox
tm_shape(midatl) + tm_polygons() +
tm_shape(ghg_utm) +
tm_dots(col="SO2_MaxReading", palette = "Greens", title="Maximum Sulfur Dioxide Reading \n(ppb)", size=0.7) +
tm_legend(legend.outside=TRUE)
### METHOD ONE: NEAREST NEIGHBOR ESTIMATE USING THIESSEN (aka dirichelet or voronoi) POLYGONS
# Create a tessellated surface
library(dismo)
voron <- voronoi(ghg_utm)
plot(voron)
midatl_agg <- aggregate(midatl)
voron_midatl <- intersect(midatl, voron)
plot(voron_midatl)
spplot(voron_midatl, 'SO2_MaxReading',col.regions=rev(get_col_regions()))
# First step: Create an empty grid where n is the total number of cells
#think of this as an emptry container to store the results of the interpolation
grd              <- as.data.frame(spsample(ghg_utm, "regular", n=50000))
# note: the key input here is ghg_utm, the EPA air quality monitoring sites
# this establishes the bounding box of a grid with give or take 50,000 cells
# examine the object "grd" in the environments. How many cells are there actually?
# note also grd is just a data frame. Watch what happens during these next steps:
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y") #take another look at "grd" again. It is now a set of "Large SpatialPoints"
gridded(grd)     <- TRUE  # Create SpatialPixel object # Now "grd" is a set of "Large SpatialPixels"
fullgrid(grd)    <- TRUE  # Create SpatialGrid object # Now "grd" is a SpatialGrid. That means it contains topological properties of cells
# Add grd's projection information to the empty grid
proj4string(ghg_utm) <- proj4string(ghg_utm) # no idea why this is necessary, but line 143 doesn't run without it!
proj4string(grd) <- proj4string(ghg_utm)
proj4string(grd)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
ghg.idw <- gstat::idw(SO2_MaxReading ~ 1, ghg_utm, newdata=grd, idp=2.0)
idw.raster <- raster(ghg.idw) # turns the "ghg.idw" object into a raster
midatlidw <- mask(idw.raster,midatl)
# Plot the estimate
tm_shape(midatlidw) +
tm_raster(n=10,palette = "RdBu", auto.palette.mapping = FALSE,
title="Predicted Max Sulfur Dioxide \n(in ppb)") +
tm_shape(ghg_utm) + tm_dots(size=0.2) +
tm_legend(legend.outside=TRUE)
## test it out - this is a good way of checking that your sample points are all well within your grid.
# If they are not, try some different values in you r x and y ranges:
plot(grd, cex=1.5)
points(ghg_utm, pch=1, col='red', cex=1)
title("Interpolation Grid and Sample Points")
# First create the variogram (differences in so2 by distances between points)
variogcloud <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm, cloud=TRUE)
plot(variogcloud)
# Now plot the lagged differences (differences by distance)
semivariog <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm)
plot(semivariog)
semivariog
#what is the shape of the semivariogram? Some possibilities:
vgm()
fit.variogram(semivariog, vgm(c("Lin", "Sph", "Mat", "Exp")))
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=200, model="Lin", nugget=90, range=23866)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
# perform the kriging operation, creation "krig" object (inspect it!)
krig <- krige(formula <- SO2_MaxReading ~ 1, locations=ghg_utm, newdata=grd, model=model.variog)
# send results to a data frame for mapping
krig.output <- as.data.frame(krig)
names(krig.output)[1:3] <- c("long","lat","var1.pred")
krig.raster <- raster(krig)
midatl.krig <- mask(krig.raster, midatl)
# Plot the estimate
tm_shape(midatl.krig) +
tm_raster(n=10,palette = "RdBu", auto.palette.mapping = FALSE,
title="Predicted Sulfur Dioxide \n(in ppm)") +
tm_shape(ghg_utm) + tm_dots(size=0.2) +
tm_legend(legend.outside=TRUE)
plot(variogcloud)
# Now plot the lagged differences (differences by distance)
semivariog <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm)
plot(semivariog)
plot(variogcloud)
# Now plot the lagged differences (differences by distance)
semivariog <- variogram(SO2_MaxReading~1, locations=ghg_utm, data=ghg_utm)
plot(semivariog)
View(midatl)
View(ghg_utm)
View(so2)
plot(voron_midatl)
spplot(voron_midatl, 'SO2_MaxReading',col.regions=rev(get_col_regions()))
### METHOD ONE: NEAREST NEIGHBOR ESTIMATE USING THIESSEN (aka dirichelet or voronoi) POLYGONS
# Create a tessellated surface
library(dismo)
voron <- voronoi(ghg_utm)
plot(voron)
midatl_agg <- aggregate(midatl)
voron_midatl <- intersect(midatl, voron)
plot(voron_midatl)
spplot(voron_midatl, 'SO2_MaxReading',col.regions=rev(get_col_regions()))
plot(voron_midatl)
View(ghg_utm)
proj4string(ghg_utm)
# these actual points appear not to have much relationship!
# But the next step would be to fit a model to what we see.
# I'm fitting a "nugget" model
model.variog <- vgm(psill=90, model="Lin", nugget=0, range=23866)
# fit the theoretical variogram to the lagged data points.
fit.variog <- fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
View(krig.output)
library(dplyr)
library(leaflet)
setwd("C:\\Users\\tuo27112\\OneDrive - Temple University\\Geoviz\\Labs\\final\\")
# tabula rasa
rm(list = ls()) #clears environment
cat("\014") #clears console
library(dplyr)
library(leaflet)
setwd("C:\\Users\\tuo27112\\OneDrive - Temple University\\Geoviz\\Labs\\final\\")
trees <- geojsonio::geojson_read("PPR_Tree_inventory_2021.geojson")
trees <- rgdal::readOGR("PPR_Tree_inventory_2021.geojson")
trees <- rgdal::readOGR("PPR_Tree_inventory_2021.geojson")
library(dplyr)
library(leaflet)
setwd("C:\\Users\\tuo27112\\OneDrive - Temple University\\Geoviz\\Labs\\final\\")
trees <- rgdal::readOGR("PPR_Tree_inventory_2021.geojson")
View(trees)
View(trees)
View(trees)
trees$TREE_NAME %>% select(contains("callery", ignore.case = TRUE))
filter(trees, TREE_NAME == "callery")
trees_subset <- subset(TREE_NAME, name %in% ("CALLERY_PEAR")
trees_subset <- subset(TREE_NAME, name %in% ("CALLERY_PEAR"))
trees_subset <- subset(TREE_NAME, name %in% substr("CALLERY_PEAR"))
trees_subset <- subset(trees$TREE_NAME, name %like% substr("CALLERY_PEAR"))
trees_subset <- subset(trees$TREE_NAME, name %in% ("CALLERY_PEAR"))
trees_subset <- trees %>%
dplyr::filter(TREE_NAME %like% "CALLERY_PEAR")
View(trees)
trees$TREE_NAME
trees_subset <- trees %>%
dplyr::filter(TREE_NAME %like% "CALLERY_PEAR")
trees_df <- as.data.frame(trees)
View(trees_df)
trees_subset <- trees_df %>%
dplyr::filter(TREE_NAME %like% "CALLERY_PEAR")
trees_subset <- trees_df %>%
dplyr::filter(TREE_NAME %in% "CALLERY_PEAR")
trees_subset <- trees_df %>%
dplyr::filter(TREE_NAME %in% "PYRUS CALLERYANA - CALLERY PEAR")
View(trees_subset)
trees_subset <- trees_df %>%
dplyr::filter(TREE_NAME == "PYRUS CALLERYANA - CALLERY PEAR")
library(sf)
toGeoJSON(trees_subset, "trees_sub_geo", c(LOC_X, LOC_Y))
library(leaflet)
toGeoJSON(trees_subset, "trees_sub_geo", c(LOC_X, LOC_Y))
tg(trees_subset, "trees_sub_geo", c(LOC_X, LOC_Y))
library(rgdal)
trees_subset[1]
trees_subset.SP  <- SpatialPointsDataFrame(trees_subset[,c(5,6)],trees_subset[,-c(6,5)])
str(trees_subset.SP) # Now is class SpatialPointsDataFrame
#Write as geojson
writeOGR(trees_subset.SP, 'callery_pears.geojson','trees_subset', driver='GeoJSON')
#Write as geojson
writeOGR(trees_subset.SP, 'callery_pears.geojson','callery_pears', driver='GeoJSON', overwrite_layer = TRUE)
library(stringr)
data1 <- iris[str_detect(iris$Species, "heaven"), ]
data1 <- trees_df[str_detect(trees_df$TREE_NAME, "heaven"), ]
View(data1)
data1 <- trees_df[str_detect(trees_df$TREE_NAME, "heaven") ]
trees_df[str_detect(trees_df$TREE_NAME, "heaven"), ]
data1 <- trees_df[trees_df$TREE_NAME %like% "heaven", ]
library("data.table")
data1 <- trees_df[trees_df$TREE_NAME %like% "heaven", ]
View(data1)
data1 <- trees_df[grep("heaven",TREE_NAME(trees_df)), ]
data1 <- trees_df[grep("heaven",rownames(trees_df)), ]
data1 <- trees_df[grep("heaven",rownames(trees_df)), ]
data1 <- trees_df[grep("heaven", trees_df$TREE_NAME), ]
data1 <- trees_df[grep("Heaven", trees_df$TREE_NAME), ]
data1 <- trees_df[grep("Heaven", trees_df$TREE_NAME), ]
data1 <- trees_df[grep("a", trees_df$TREE_NAME), ]
data1 <- trees_df[grep("HEAVEN", trees_df$TREE_NAME), ]
data1(head)
head(data1)
trees_subset <- trees_df %>%
dplyr::filter(TREE_NAME == "AILANTHUS ALTISSIMA - TREE OF HEAVEN")
tg(trees_subset, "trees_sub_geo", c(LOC_X, LOC_Y))
trees_subset.SP  <- SpatialPointsDataFrame(trees_subset[,c(5,6)],trees_subset[,-c(6,5)])
str(trees_subset.SP) # Now is class SpatialPointsDataFrame
#Write as geojson
writeOGR(trees_subset.SP, 'heaven.geojson','heaven', driver='GeoJSON', overwrite_layer = TRUE)
